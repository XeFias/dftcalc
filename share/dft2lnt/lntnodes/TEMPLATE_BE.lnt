(* Basic event with possible non-failure probability.
 * Input rates:
 * RATE_FAIL !1 !1: Dormant failure rate (mu, per-phase)
 * RATE_FAIL !1 !2: Active failure rate (lambda, per-phase)
 * RATE_FAIL !2 !1: Dormant non-failure rate (lambda * (1/p - 1))
 * RATE_FAIL !2 !1: Active non-failure rate (mu * (1/p - 1))
 *
 * A note on the combination of prob and repairs: A repairable BE will
 * decide once whether it can ever fail or not. A BE that has
 * determined that it can fail (by undergoing any degradation at all)
 * will never enter a failsafe state after repairs. Similarly, a
 * failsafe BE with remain failsafe after attempted repairs.
 *)
module TEMPLATE_BE(TEMPLATE_COMMON_APH_REPAIR) is
	process BEproc [FAIL : NAT_CHANNEL,
	                ACTIVATE : NAT_BOOL_CHANNEL,
	                RATE_FAIL : NAT_NAT_CHANNEL,
	                REPAIRED : NAT_BOOL_CHANNEL,
	                INSPECT : NAT_CHANNEL,
	                ONLINE : NAT_CHANNEL,
	                DEACTIVATE : NAT_BOOL_CHANNEL]
		(cold: BOOL, initial: STATUS, phases: NAT,
		 threshold : NAT, repairable: BOOL, always_active: BOOL)
	is var
		status : STATUS,
		isactive : BOOL,
		emit_fail : BOOL,
		emit_online : BOOL,
		emit_inspect : BOOL,
		can_definitely_fail: BOOL,
		degenerated : NAT
	in
		status := initial;
		emit_fail := FALSE;
		can_definitely_fail := FALSE;
		emit_inspect := FALSE;
		if (initial == FAILING) then
			emit_fail := TRUE;
			if (threshold >= 0 of NAT) then
				emit_inspect := TRUE
			end if;
			status := UP
		end if;
		isactive := always_active;
		degenerated := phases;
		emit_online := FALSE;
		loop
			select
			(* Note: Activation/deactivation logic will get
			 *       really screwy if a BE has multiple
			 *       parents that disagree about the status.
			 *)
				if not(always_active) then
					ACTIVATE (!0 of NAT, FALSE);
					isactive := TRUE
				end if

			[]
				if not(always_active) then
					DEACTIVATE (!0 of NAT, FALSE);
					isactive := FALSE
				end if

			(*
			 * When this BE is in the UP state, it can fail with the
			 * failure rate associated with this state. The rate is later
			 * introduced using renaming of RATE_FAIL !1 !1.
			 * If the failure event is triggered, go into the FAILED state.
			 *)
			[]
				if ((not (cold)) and (status == UP) and (not(isactive))) then
					RATE_FAIL (!1 of NAT,1 of NAT);
					can_definitely_fail := TRUE;
					degenerated := degenerated-1;
					if (degenerated < 1) then
						emit_fail := TRUE;
						status := DOWN
					end if;
					if ((phases-degenerated) == threshold) then
						emit_inspect := TRUE
					end if
				end if

			 (* If the BE is in the first degradation phase,
			  * and has a non-failure probability
			  * (converted to a rate), the BE might move to
			  * a failsafe state.
			  *)
			[]
				if ((not (cold))
				    and (status == UP)
				    and not(isactive)
				    and not(can_definitely_fail)
				    and (degenerated == phases))
				then
					RATE_FAIL (!2 of NAT,1 of NAT);
					status := FAILSAFE
				end if
			[]
				if (emit_inspect) then
					INSPECT (!0 of NAT);
					emit_inspect := false
				end if

			[]
			(* Always emit the fail signal before a repair, to
			   avoid strange behaviour in the gates
			 *)
				if (emit_fail) then
					FAIL (!0 of NAT);
					emit_fail := FALSE
				elsif (emit_online) then
					ONLINE (!0 of NAT);
					emit_online := FALSE
				end if

			(*
			 * When this BE is in the ACTIVE state, it can fail with the
			 * failure rate associated with this state. The rate is later
			 * introduced using renaming of RATE_FAIL !1 !2.
			 * If the failure event is triggered, go into the FAILED state.
			 *)
			[]
				if (isactive and (status == UP)) then
					RATE_FAIL (!1 of NAT,2 of NAT);
					can_definitely_fail := TRUE;
					degenerated := degenerated-1;
					if (degenerated < 1 of NAT) then
						emit_fail := TRUE;
						status := DOWN
					end if;
					if ((phases-degenerated) == threshold) then
						emit_inspect := TRUE
					end if
				end if

			(* Probability of non-failure *)
			[]
				if (isactive
				    and (status == UP)
				    and not(can_definitely_fail))
				then
					RATE_FAIL (!2 of NAT,2 of NAT);
					status := FAILSAFE
				end if

			-- listen if repair is finished active branch
			[]
				if repairable then
					REPAIRED (!0 of NAT,FALSE);
					degenerated := phases;
					if (status == DOWN) then
						emit_online := TRUE;
						emit_inspect := FALSE
					end if;
					if (status != FAILSAFE) then
						status := UP
					end if
				end if
			end select
		end loop
	end var
	end process
end module
