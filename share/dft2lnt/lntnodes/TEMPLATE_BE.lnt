module TEMPLATE_BE(TEMPLATE_COMMON_APH_REPAIR) is

	process BEproc [FAIL : NAT_CHANNEL,
	                ACTIVATE : NAT_BOOL_CHANNEL,
	                RATE_FAIL : NAT_NAT_CHANNEL,
	                REPAIRED : NAT_BOOL_CHANNEL,
	                INSPECT : NAT_CHANNEL,
	                ONLINE : NAT_CHANNEL,
	                DEACTIVATE : NAT_BOOL_CHANNEL]
		(cold: BOOL, initial: STATUS, phases: NAT,
		 threshold : NAT, repairable: BOOL, always_active: BOOL)
	is var
		status : STATUS,
		isactive : BOOL,
		emit_fail : BOOL,
		emit_online : BOOL,
		emit_inspect : BOOL,
		degenerated : NAT
	in
		status := initial;
		emit_fail := FALSE;
		emit_inspect := FALSE;
		if (initial == FAILING) then
			emit_fail := TRUE;
			if (threshold >= 0 of NAT) then
				emit_inspect := TRUE
			end if;
			status := UP
		end if;
		isactive := always_active;
		degenerated := phases;
		emit_online := FALSE;
		loop
			select
			(* Note: Activation/deactivation logic will get
			 *       really screwy if a BE has multiple
			 *       parents that disagree about the status.
			 *)
				if not(always_active) then
					ACTIVATE (!0 of NAT, FALSE);
					isactive := TRUE
				end if

			[]
				if not(always_active) then
					DEACTIVATE (!0 of NAT, FALSE);
					isactive := FALSE
				end if

			(*
			 * When this BE is in the UP state, it can fail with the
			 * failure rate associated with this state. The rate is later
			 * introduced using renaming of RATE_FAIL !1 !1.
			 * If the failure event is triggered, go into the FAILED state.
			 *)
			[]
				if ((not (cold)) and (status == UP) and (not(isactive))) then
					RATE_FAIL (!1 of NAT,1 of NAT);
					degenerated := degenerated-1;
					if (degenerated < 1) then
						emit_fail := TRUE;
						status := DOWN
					end if;
					if ((phases-degenerated) == threshold) then
						emit_inspect := TRUE
					end if
				end if
			[]
				if (emit_inspect) then
					INSPECT (!0 of NAT);
					emit_inspect := false
				end if

			[]
			(* Always emit the fail signal before a repair, to
			   avoid strange behaviour in the gates
			 *)
				if (emit_fail) then
					FAIL (!0 of NAT);
					emit_fail := FALSE
				elsif (emit_online) then
					ONLINE (!0 of NAT);
					emit_online := FALSE
				end if

			(*
			 * When this BE is in the ACTIVE state, it can fail with the
			 * failure rate associated with this state. The rate is later
			 * introduced using renaming of RATE_FAIL !1 !2.
			 * If the failure event is triggered, go into the FAILED state.
			 *)
			[]
				if (isactive and (status == UP)) then
					RATE_FAIL (!1 of NAT,2 of NAT);
					degenerated := degenerated-1;
					if (degenerated < 1 of NAT) then
						emit_fail := TRUE;
						status := DOWN
					end if;
					if ((phases-degenerated) == threshold) then
						emit_inspect := TRUE
					end if
				end if

			-- listen if repair is finished active branch
			[]
				if repairable then
					REPAIRED (!0 of NAT,FALSE);
					degenerated := phases;
					if (status == DOWN) then
						emit_online := TRUE;
						emit_inspect := FALSE
					end if;
					status := UP
				end if
			end select
		end loop
	end var
	end process
end module
