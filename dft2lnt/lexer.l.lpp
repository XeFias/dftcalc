%option reentrant
%option bison-bridge
%option bison-locations
/*%option noyywrap*/
%option yylineno
%option extra-type="Parser*"

/* Inserted in .c and .h */
%top{
	#ifndef __PARSER_Y_HPP
	#define __PARSER_Y_HPP
	#	include "parser.y.hpp"
	#endif
}

%{
	#include <stdio.h>
	#include <cstring>
	#include <string.h>
	#include <string>
	//#ifndef __PARSER_Y_HPP
	//#define __PARSER_Y_HPP
	//#endif
	#include <ctype.h>
	#define YY_USER_ACTION  { Parser* currentParser = NULL; yylloc->last_column += yyleng; /*LOCATION_PRINT(stderr,yylloc); printf("\n");*/ }
	#define YY_USER_INIT { LOCATION_RESET (*yylloc); }
	#define COMPILING_LEXER
	#include "dft_types.h"
	#include "dft_parser.h"
	char *my_strdup(const char *str);
	int lex_char(yyscan_t yyscanner);
	#define compiler_lexer_report_error(str) currentParser->getCC()->reportErrorAt(*yylloc,str)
	#define compiler_lexer_report_warning(str) currentParser->getCC()->reportWarningAt(*yylloc,str)
	#define compiler_lexer_report_errorAt(loc,str) { /*printf("@%i: ",__LINE__);*/ currentParser->getCC()->reportErrorAt(loc,str); }
	#define compiler_lexer_report_warningAt(loc,str) { currentParser->getCC()->reportWarningAt(loc,str); }
	
	// The parameter currentParser is not always used, so ignore warning
	#pragma GCC diagnostic push
	#pragma GCC diagnostic ignored "-Wunused-variable"
%}

underscore    [_]
digit         [0-9]
letter        [A-Za-z]
number        {digit}+
numbersuffix  {number}({letter}|{underscore})*
voting        {number}of{number}
hexdigit	  {digit}|[A-F]
newline       \r?\n
whitespace    [ \t]+
hexnumber     {hexdigit}+h
address       0x{hexdigit}+
identifier    ({letter}|{underscore})({letter}|{underscore}|{digit})*
char          [L]?[']
pp_include    {preproc}{whitespace}?include
pp_line       {preproc}line
preproc       [#]
comment_line  [\/][\/][^\n\r]*{newline}
comment_block [\/][*][A][*][\/]
string        [L]?["]
float         {number}[.]{number}
transfer      "accepts transfers from"
%%
%{
	Parser* currentParser = (Parser*)yyextra;
	/* At each yylex invocation, mark the current position as the
	 * start of the next token.
	*/
	/*LOCATION_STEP (*yylloc);*/
%}

{pp_line} {
	register int c;
	while( (c = yyinput(yyscanner)) == ' ' ) {
	}

	char buffer[300];
	int buflen = 0;
	buffer[buflen++] = c;
	while( (c = yyinput(yyscanner)) != ' ' ) {
		buffer[buflen++] = c;
	}
	buffer[buflen] = '\0';
	int line = atoi(buffer);

	buflen = 0;
	if( (c = yyinput(yyscanner)) && c != '"') {
		buffer[buflen++] = c;
	}
	while( (c = yyinput(yyscanner)) != ' ' && c != EOF && c != '\r' && c != '\n' ) {
		buffer[buflen++] = c;
	}
	if(buffer[buflen-1]=='"') {
		buffer[buflen-1] = '\0';
	} else {
		buffer[buflen] = '\0';
	}

	//printf("found #line %i %s\n",line,buffer);
	LOCATION_SET(*yylloc,line,std::string(buffer));
}

"/*" {
	register int c;

	for(;;) {
		while( (c = yyinput(yyscanner)) != '*' && c != EOF && c != '\r' && c != '\n' ) {
		}

		if(c == '*') {
			while( (c = yyinput(yyscanner)) == '*' ) {
			}
			if(c == '/')
				break;    /* found the end */
		} else if(c == '\r') {
			c = yyinput(yyscanner);
			LOCATION_LINES(*yylloc,1);
			if(c != '\n' && c != EOF)
				unput(c);
		} else if( c == '\n') {
			LOCATION_LINES(*yylloc,1);
		}

		if(c == EOF) {
			compiler_lexer_report_warning("EOF in comment");
			
			unput(c);
			break;
		}
	}
}

{comment_line}          LOCATION_LINES(*yylloc, 1); LOCATION_STEP (*yylloc); 
{float}                 sscanf(yytext,"%f",&yylval->f_number); return FLOAT;
 /*{hexnumber}             sscanf(yytext,"%X",&yylval.number); return HEXNUMBER;*/
 /*{address}               yylval.address = my_strdup(yytext+2); return ADDRESS;*/
{newline}               LOCATION_LINES(*yylloc, 1); LOCATION_STEP (*yylloc);
{whitespace}            LOCATION_STEP(*yylloc); /* ignore whitespace */;

{voting} {
	char buffer[101];

	// Read first number (threshold)
	char* dst = buffer;
	char* src = yytext;
	while(isdigit(*src)) {
		*dst++ = *src++;
	}
	*dst = '\0';
	yylval->voting.k = atoi(buffer);

	// Read second number (total)
	dst = buffer;
	src+=2;
	while(isdigit(*src)) {
		*dst++ = *src++;
	}
	*dst = '\0';
	yylval->voting.n = atoi(buffer);

	return VOTING;
}
{number} {
	int c;
	char buffer[101];
	buffer[0] = 0;
	unsigned int buflen = 0;

	for(;(c=yyinput(yyscanner));) {
		if(buflen>=100) {
			compiler_lexer_report_error("suffix too long");
			break;
		}
		if( isalpha(c) || c=='_') {
			buffer[buflen++] = c;
		} else {
			break;
		}
	}
	if(c && c!=EOF) {
		unput(c);
	}
	if(buflen) {
		buffer[buflen] = 0;
		yylval->numbersuffix.suffix = my_strdup(buffer);
		yylval->numbersuffix.number=atoi(yytext);return NUMBERSUFFIX;
	} else {
		yylval->number=atoi(yytext);return NUMBER;
	}
}

{string} {
	register int c;
	char* s = NULL;
	unsigned int s_len = 0;

	for(;;) {
		c = yyinput(yyscanner);

		if(c == '\\') {
			c = lex_char(yyscanner);
		} else if(c == '"') {
			break;
		}

		if(c == EOF) {
			fprintf(stderr,"EOF in string!");
			break;
		}
		s = (char*)realloc(s,s_len+1);
		s[s_len++] = c;
	}
	s = (char*)realloc(s,s_len+1);
	s[s_len++] = '\0';
	yylval->c_string=s;
	return STRING;
}

{char} {
	int c = yyinput(yyscanner);
	if(c == '\\') {
		yylval->character = lex_char(yyscanner);
		c = yyinput(yyscanner);
		if(c!='\'') {
			compiler_lexer_report_error("char not terminated");
			unput(c);
		}
	} else if(c == '\'') {
		yylval->character = 0;
	} else {
		yylval->character = c;
		c = yyinput(yyscanner);
		if(c!='\'') {
			compiler_lexer_report_error("char not terminated");
			unput(c);
		}
	}
	return CHAR;
}

;                       return(SEMICOLON);
=                       return(EQUALS);

toplevel                return(TOPLEVEL);
page                    return PAGE;
phase                   return PHASE;

 /* gates */
phasedor                { yylval->c_string=my_strdup(yytext); return PHASEDOR; }
or                      { yylval->c_string=my_strdup(yytext); return OR;       }
and                     { yylval->c_string=my_strdup(yytext); return AND;      }
hsp                     { yylval->c_string=my_strdup(yytext); return HSP;      }
wsp                     { yylval->c_string=my_strdup(yytext); return WSP;      }
csp                     { yylval->c_string=my_strdup(yytext); return CSP;      }
pand                    { yylval->c_string=my_strdup(yytext); return PAND;     }
seq                     { yylval->c_string=my_strdup(yytext); return SEQ;      }
of                      { yylval->c_string=my_strdup(yytext); return OF;       }
fdep                    { yylval->c_string=my_strdup(yytext); return FDEP;     }
{transfer}              { yylval->c_string=my_strdup(yytext); return TRANSFER; }

 /* Attributes */
prob                    { yylval->c_string=my_strdup(yytext); return PROB;   }
lambda                  { yylval->c_string=my_strdup(yytext); return LAMBDA; }
rate                    { yylval->c_string=my_strdup(yytext); return RATE;   }
shape                   { yylval->c_string=my_strdup(yytext); return SHAPE;  }
mean                    { yylval->c_string=my_strdup(yytext); return MEAN;   }
stddev                  { yylval->c_string=my_strdup(yytext); return STDDEV; }
cov                     { yylval->c_string=my_strdup(yytext); return COV;    }
res                     { yylval->c_string=my_strdup(yytext); return RES;    }
repl                    { yylval->c_string=my_strdup(yytext); return REPL;   }
dorm                    { yylval->c_string=my_strdup(yytext); return DORM;   }
aph                     { yylval->c_string=my_strdup(yytext); return APH;    }

{identifier} {
	yylval->c_string=my_strdup(yytext);
	return IDENTIFIER;
}

%%
char *my_strdup(const char *str) {
	size_t len = strlen(str);
	char *x = (char*)malloc(len+1); /* 1 for the null terminator */
	if(!x) return NULL; /* malloc could not allocate memory */
	memcpy(x,str,len+1); /* copy the string into the new buffer */
	return x;
}

int lex_char(yyscan_t yyscanner) {
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	Parser* currentParser = yyextra;\
	register int c = yyinput(yyscanner);

		if(c == EOF) {
		} else if(c == '\\') {
		} else if(c == '\'') {
		} else if(c == '"') {
		} else if(c == 'n') {
			c = '\n';
		} else if(c == 'r') {
			c = '\r';
		} else if(c == 'b') {
			c = '\b';
		} else if(c == 't') {
			c = '\t';
		} else if(c == 'f') {
			c = '\f';
		} else if(c == 'a') {
			c = '\a';
		} else if(c == 'v') {
			c = '\v';
		} else if(c == '?') {
			c = '\?';
		} else if(isdigit(c)) {
			char buffer[101];
			int buflen = 0;
			do {
				if(buflen>=100) {
					compiler_lexer_report_error("octal number in string too long");
					break;
				}
				buffer[buflen++] = c;
				c = yyinput(yyscanner);
			} while(isdigit(c));
			unput(c);
			buffer[buflen] = 0;
			sscanf(buffer,"%o",&c);
		} else if(c == 'x') {
			char buffer[101];
			int buflen = 0;
			while( (c = yyinput(yyscanner)) && isdigit(c) ) {
				if(buflen>=100) {
					compiler_lexer_report_error("hexadecimal number in string too long");
					break;
				}
				buffer[buflen++] = c;
			}
			unput(c);
			buffer[buflen] = 0;
			sscanf(buffer,"%X",&c);
		}
	return c;
}
#pragma GCC diagnostic pop